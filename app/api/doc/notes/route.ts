/**
 * Get the code from here: https://github.com/StphnLwnga/rag-101/blob/main/api/src/notes/index.ts
 */

// import { auth } from "@clerk/nextjs";
import { NextResponse } from "next/server";
import axios from "axios";
import { PDFDocument } from 'pdf-lib';
import * as fs from 'fs';
import path from 'path';
import { v4 as uuidv4 } from 'uuid';
import { formatDocumentsAsString } from "langchain/util/document";
import { PDFLoader } from "langchain/document_loaders/fs/pdf";
import { Document } from "langchain/document";
import * as pdfs from "@/lib/mock.json";
import { loadPdfFromUrl, convertPdfToDocuments } from "@/lib/helpers";
import { Paper } from "@/lib/types";


/**
 * Sends a POST request to the OpenAI API to generate a summary of the PDF 
 * with the given title and URL and saves it in the database.
 *
 * @param {Request} req - The request object.
 * @return {Promise<NextResponse>} A promise that resolves to a NextResponse object.
 */
export async function POST(req: Request): Promise<NextResponse> {
	const parsedPdfs = JSON.parse(fs.readFileSync("lib/mock.json", "utf-8"));

	try {
		// const { userId } = auth();
		// if (!userId) throw new Error("Unauthorized");

		// Extract PDF title, URL & pages to delete from request body
		const { pdfTitle, pdfUrl, pagesToDelete } = await req.json();

		if (!pdfTitle || !pdfUrl)
			return new NextResponse("Invalid request, name and URL are required", { status: 400 });

		// TODO: Check if the PDF already exists in the database and handle accordingly

		/**
		 * Extract the title from the request's body.
		 * Generate the summary using the OpenAI API.
		 * Save the title and summary in the database.
		 * Return the PDF with the title and summary.
		*/

		if (parsedPdfs.some((pdf: Paper) => pdf.pdf_url === pdfUrl))
			return NextResponse.json({
				pdfExists: true,
				pdfId: parsedPdfs.find((pdf: Paper) => pdf.pdf_url === pdfUrl)?.id,
			}, { status: 200 });

		const pdfAsBuffer = await loadPdfFromUrl({ url: pdfUrl });

		const docs = await convertPdfToDocuments(pdfAsBuffer, pdfTitle);

		const pdfData = {
			id: uuidv4(),
			pdf_text: formatDocumentsAsString(docs),
			pdf_url: pdfUrl,
			notes: [
				{
					note: "This is a note generated by an LLM based on the content of the PDF.",
					page_numbers: [1],
				},
			],
			pdf_title: pdfTitle,
			pdfAsBuffer,
			created_at: new Date().toISOString(),
		}

		const path = `lib/mock.json`;
		parsedPdfs.push({
			id: pdfData.id,
			pdf_title: pdfData.pdf_title,
			pdf_url: pdfData.pdf_url,
			pdf_text: pdfData.pdf_text,
			created_at: pdfData.created_at,
			notes: pdfData.notes,
		});
		fs.writeFileSync(path, JSON.stringify(parsedPdfs), "utf-8");

		return NextResponse.json({ pdfId: pdfData.id }, { status: 200 });
	} catch (error) {
		console.log("[NOTES_GENERATE]", error);
		return new NextResponse("Internal Error", { status: 500 });
	}
}

/**
 * Retrieves all the PDF files and associated QA chat history for that file from the database.
 *
 * @param {Request} req - The request object.
 * @return {Promise<NextResponse>} A promise that resolves to a NextResponse object containing the notes as JSON.
 */
export async function GET(req: Request): Promise<NextResponse> {
	try {
		// const { userId } = auth();
		// if (!userId) return new NextResponse("Unauthorized", { status: 401 });

		/**
		 * Retrieve all the PDF files and associated QA chat history from the database.
		 */

		// Mock notes data
		const pdfsStr = fs.readFileSync("lib/mock.json", "utf-8");
		const parsedPdfs = JSON.parse(pdfsStr) as Paper[];
		// console.log(parsedPdfs)
		const data = parsedPdfs.map((paper: Paper) => ({
			id: paper.id,
			pdf_title: paper.pdf_title,
			pdf_url: paper.pdf_url,
			created_at: paper.created_at,
		} as Partial<Paper>));

		data.sort((a, b) => b?.created_at!.localeCompare(a?.created_at!));

		return NextResponse.json(data);
	} catch (error) {
		console.log("[NOTES_GET]", error);
		return new NextResponse("Internal Error", { status: 500 });
	}
}
